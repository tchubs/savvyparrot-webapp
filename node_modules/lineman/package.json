{
  "name": "lineman",
  "description": "A grunt-based project scaffold for HTML/CSS/JS apps",
  "version": "0.8.2",
  "homepage": "https://github.com/testdouble/lineman",
  "author": {
    "name": "Justin Searls",
    "email": "justin@testdouble.com"
  },
  "preferGlobal": true,
  "repository": {
    "type": "git",
    "url": "git://github.com/testdouble/lineman.git"
  },
  "bugs": {
    "url": "https://github.com/testdouble/lineman/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://mit-license.org"
    }
  ],
  "bin": {
    "lineman": "./cli.js"
  },
  "main": "lineman",
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "grunt": "0.4.1",
    "grunt-contrib-clean": "0.4.1",
    "grunt-contrib-coffee": "0.7.0",
    "grunt-contrib-concat": "0.3.0",
    "grunt-contrib-handlebars": "0.5.8",
    "grunt-contrib-jshint": "0.5.1",
    "grunt-contrib-jst": "0.5.0",
    "grunt-contrib-less": "0.5.1",
    "grunt-contrib-sass": "0.3.0",
    "grunt-contrib-cssmin": "0.6.0",
    "grunt-contrib-uglify": "0.2.0",
    "grunt-watch-nospawn": "0.0.3",
    "node.extend": "1.0.6",
    "testem": "0.2.96",
    "commander": "1.1.1",
    "express": "3.2.4",
    "http-proxy": "0.10.2",
    "coffee-script": "1.6.2",
    "watch_r": "0.0.3",
    "semver": "1.1.4"
  },
  "keywords": [
    "lineman"
  ],
  "readme": "# Lineman\n\n[![Build Status](https://secure.travis-ci.org/testdouble/lineman.png)](http://travis-ci.org/testdouble/lineman)\n\nLineman is a tool to help you build fat-client webapp projects. It requires [node.js](http://nodejs.org) & [npm](http://npmjs.org) and wouldn't be possible without [grunt](https://github.com/cowboy/grunt).\n\nFor an overview, consider checking out the [demo screencast](http://www.youtube.com/watch?v=BmZ4XRErYAI)!\n\n## Why Lineman?\n\nSuppose that you're starting a new [single page web application](http://en.wikipedia.org/wiki/Single-page_application) and you want to reap the benefits of loose coupling between your client-side and server side. If that rings true, then Lineman (and similar tools) can help to keep you as productive working in the front-end as [traditional HTML generation frameworks](http://rubyonrails.org) do on the back-end.\n\nNow, for the features!\n\nLineman is a *productivity* tool, in that it provides a development server which:\n\n* Serves up your app on a [local development server](https://github.com/testdouble/lineman#development) at [localhost:8000](http://localhost:8000)\n* Compiles your [CoffeeScript](http://coffeescript.org) into JavaScript as soon as you save a file\n* Immediately compiles your [Sass](http://sass-lang.com) and [Less](http://lesscss.org) into CSS\n* Provides [tools to stub out your back-end API services](https://github.com/testdouble/lineman#stubbing-server-side-endpoints) with [express](http://expressjs.com)\n* Compiles your JavaScript templates (e.g. Underscore, Handlebars) to a `window.JST` object that maps their file path to the compiled template function\n* Can ease development by [proxying XHRs to your server-side app](https://github.com/testdouble/lineman#proxying-requests-to-another-server)\n* [Features a *delightful* spec runner](https://github.com/testdouble/lineman#specs) called [Testem](https://github.com/airportyh/testem), which comes pre-configured for Jasmine\n\nLineman is also a *build* tool, because when you're ready to deploy:\n\n* You can [deploy to Heroku](https://github.com/testdouble/lineman#heroku) just by committing and pushing with git\n* Assemble your app into a [ready-to-deploy `dist` directory](https://github.com/testdouble/lineman#static-assets)\n* Run your specs headlessly for a [continuous integration build](https://github.com/testdouble/lineman#continuous-integration-specs)\n\nAt the end of the day, Lineman is just a handful of conventions and grunt task configurations that can help you get up-and-running more quickly than rolling your own. It's easy to extend and modify as your application grows.\n\n## Getting started\n\nFirst, you'll need [node.js](http://nodejs.org). If you plan on running tests, you'll also want [PhantomJS](http://phantomjs.org) somewhere on your PATH. (This is where [the aforementioned screencast picks up](http://searls.testdouble.com/2012/10/13/say-hello-to-lineman/).)\n\nNext, you'll need to install Lineman globally:\n\n``` bash\n$ npm install -g lineman\n```\n\nOnce Lineman is installed, you can either ask it to generate a new project for you, or you might consider cloning from a pre-existing template.\n\n### lineman new\n\nTo create a new project, run the `lineman` binary with the `new` command and tell it where you'd like the project to go:\n\n``` bash\n$ lineman new my-project\n```\n\nThis will create a new directory named \"my-project\" and copy in Lineman's [archetypal project](https://github.com/testdouble/lineman/tree/master/archetype).\n\n### Starting from a template\n\nWe have a few template projects floating around to help you get up-and-running *even more faster*.\n\n* Using [Backbone.js](https://github.com/davemo/lineman-backbone-template)\n* Using [Angular.js](https://github.com/davemo/lineman-angular-template)\n* Using [Ember.js](https://github.com/searls/lineman-ember-template)\n* Building a [Markdown blog](https://github.com/testdouble/lineman-blog)\n\n## Working with Lineman\n\n### Development\n\nTo see all of the options available to you in the terminal use the `-h` or `--help` option:\n\n``` bash\n$ lineman --help\n```\n\nFrom the project directory, you can start a server at [localhost:8000](http://localhost:8000):\n\n``` bash\n$ lineman run\n```\n\nInternally, Grunt's `watch` task will monitor for file changes; in turn, Lineman's default configuration will fire the appropriate tasks when a file of a given type is saved.\n\nWith any luck, visiting the server in your browser will yield something as *beautiful* as this:\n\n![Development Screenshot](http://i.minus.com/i1vI8cdB0tRPK.png)\n\nThe Hello World code shows off JST compilation, CoffeeScript, and Less. When you edit a source file, your changes are usually reflected by the time you can refresh your browser.\n\n#### Server-side APIs\n\nLineman has a very narrow focus: helping you build client-side apps as a collection of ready-to-deploy static assets. That said, almost all nontrivial client-side apps require some interaction with a server, and no developer could be expected to write working code without either faking the server-side or plugging the client and server together. Lineman offers support for both!\n\n##### Stubbing server-side endpoints\n\nUsers may define custom HTTP services to aid development in `config/server.js` by exporting a function named `drawRoutes`. Here's a trivial example:\n\n``` javascript\nmodule.exports = {\n  drawRoutes: function(app) {\n    app.get('/api/greeting/:message', function(req, res){\n      res.json({ message: \"OK, \"+req.params.message });\n    });\n  }\n};\n```\n\nWith this definition in place, if the client-side app makes a request to \"/api/greeting/ahoy!\", this route will handle the request and return some JSON.\n\nBecause Lineman uses [express](http://expressjs.com) for the development server, please reference its documentation for details on all the nifty things you can do.\n\n#### Proxying requests to another server\n\nLineman also provides a facility to forward any requests that it doesn't know how to respond to a proxy service. Typically, if you're developing a client-side app in Lineman and intend to pair it to a server-side app (written, say, in Ruby on Rails), you could run a local Rails server on port 3000 while running Lineman, and your JavaScript could seamlessly send requests to Rails on the same port as Lineman's development server.\n\nTo enable proxying, set the `enabled` flag on the `apiProxy` configuration of the `server` task in `config/application.js`, like this:\n\n``` javascript\n  server: {\n    apiProxy: {\n      enabled: true,\n      port: 3000\n    }\n  }\n```\n\nWith this feature, you'll be able to develop your client-side and server-side code in concert, while still keeping the codebases cleanly separated.\n\n### Specs\n\nLineman provides a way to run your specs constantly as you work on your code with the `lineman spec` command:\n\n``` bash\n$ lineman spec\n```\n\n**Heads up!** `lineman spec` only runs your tests, so be sure to keep `lineman run` running in another process (e.g. an extra terminal tab) to continue to monitor file changes.\n\nThe `spec` command will launch the fantastic test framework [Testem](https://github.com/airportyh/testem) supports Safari, Chrome, Firefox, Opera, PhantomJS and (IE9, IE8, IE7 if on Windows). By default we have configured Testem to launch Chrome for tests during development.\n\nYou can override this by modifying the `launch_in_dev` property within `config/spec.json`\n\nWe have found that running tests in Chrome during development is ideal as it enables the insertion of `debugger;` statements into javascript which allows debugging in the browser.\n\n##### Growl/Growl-ish notification\n\nYou can also enable testem [Growl/Growl-ish notification](https://github.com/airportyh/testem#growl-or-growl-ish-notifications) so you don't have to look at terminal while developing.\nTo enable this feature, set the `growl` flag on the `options` property of the `spec` task in `config/application.js`, like this:\n\n``` javascript\n  spec: {\n    options: {\n      growl: true\n    }\n  }\n```\n\n### Continuous Integration Specs\n\nYou can also run specs with output generated for your CI environment in [TAP 13](http://en.wikipedia.org/wiki/Test_Anything_Protocol) format:\n\n``` bash\n$ lineman spec-ci\n```\n\nThis configuration executes specs headlessly using only PhantomJS. You can override this by modifying the `launch_in_ci` property within `config/spec.json`\n\n### Production\n\nWhen you're ready to send your application off to a remote server, just run the `lineman build` task.\n\n``` bash\n$ lineman build\n```\n\nThe above runs a task that produces a production-ready web application in the project's `dist/` directory.\n\n### Cleaning\n\nTo clean the two build directories (`dist` and `generated`), just run the clean task:\n\n``` bash\n$ lineman clean\n```\n\n## Project directory structure\n\nLineman generates a very particular directory structure. It looks like this:\n\n``` bash\n.\n├── app\n│   ├── js                  # <-- JS & CoffeeScript\n│   ├── img                 # <-- images (are merged into the 'img' folder inside of generated & dist)\n│   └── templates           # <-- client-side templates\n│       ├── homepage.us     # <-- a template used to produce the application's index.html\n│       ├── other.us        # <-- other templates will be compiled to a window.JST object\n│       └── thing.hb        # <-- underscore & handlebars are both already set up\n│       └── _partial.hb     # <-- a handlebars partial, usable from within other handlebars templates\n├── config\n│   ├── application.js      # <-- Override application configuration\n│   ├── files.js            # <-- Override named file patterns\n│   ├── server.js           # <-- Define custom server-side endpoints to aid in development\n│   └── spec.json           # <-- Override spec run configurations\n├── dist                    # <-- Generated, production-ready app assets\n├── generated               # <-- Generated, pre-production app assets\n├── grunt.js                # <-- gruntfile defines app's task config\n├── package.json            # <-- Project's package.json\n├── tasks                   # <-- Custom grunt tasks can be defined here\n├── spec\n│   ├── helpers             # <-- Spec helpers (loaded before other specs)\n│   └── some-spec.coffee    # <-- All the Jasmine specs you can write (JS or Coffee)\n└── vendor                  # <-- 3rd-party assets will be prepended or merged into the application\n    ├── js                  # <-- 3rd-party Javascript\n    │   └── underscore.js   # <-- Underscore, because underscore is fantastic.\n    ├── img                 # <-- 3rd-party images (are merged into the 'img' folder inside of generated & dist)\n    └── css                 # <-- 3rd-party CSS\n\n```\n\n## Custom Tasks\n\nLineman can easily be extended to do extra grunt-work for your application above-and-beyond the built-in grunt tasks. You may add tasks to your project in two ways:\n\n* If you're writing a task yourself, add it to the `tasks/` directory. Lineman will automatically load any tasks found here.\n* If you want to use a task that's packaged in an external npm module, add it to your `package.json` as a dependency and run `npm install`.\n\nOnce they're loaded, you can manually run the task from the command line using `lineman grunt` (which just delegates through to `grunt`):\n\n```bash\n$ lineman grunt taskname\n```\n\nBut you're probably more interested in adding the custom task to run along with the other tasks in `lineman run` and/or `lineman build`. You can add any task to these commands by adding it to the appropriate array under the `appendTasks` object in `config/application.js`:\n\n```javascript\n  prependTasks: {\n    common: [\"A\"],\n    dev: [\"B\"],\n    dist: [\"C\"]\n  },\n  appendTasks: {\n    common: [\"D\"],\n    dev: [\"E\"],\n    dist: [\"F\"]\n  }\n```\n\nIn the above example, tasks \"A\" & \"D\" would run during *both* `lineman run` and `lineman build`. Meanwhile, \"B\" & \"E\" would run only during `lineman run`, while \"C\" & \"F\" would only run during `lineman build`.\n\nTasks specified under `prependTasks` way will be run before Lineman's built-in tasks for the corresponding phase, while tasks specified under `appendTasks` will run immediately afterward. For reference, [check out](https://github.com/testdouble/lineman/blob/master/config/application.coffee#L11-L14) Lineman's default configuration.\n\nIf you need more fine-grained control—say you want to *replace or remove* a default task—you can use custom JavaScript in your application config file to edit the appropriate array directly; [here's an example of removing a task](https://github.com/searls/lineman-ember-template/blob/master/config/application.coffee#L10-L14) from the [Ember.js template](https://github.com/searls/lineman-ember-template).\n\n#### Removing tasks\n\nBut that's not all! If you need to remove a task that's built into Lineman, you can use the \"removeTasks\" configuration. For example, if you wanted to disable Lineman's CoffeeScript task, you could do this:\n\n```javascript\n  removeTasks: {\n    common: [\"coffee\"]\n  }\n```\n\n### Adding NPM based tasks\n\nTo load NPM-based tasks that aren't part of the standard Lineman dependencies, you can add the module names to the `loadNpmTasks` object in `config/application.js`. Note that these still need to be added to your app's `package.json` dependencies and installed to `node_modules` with `npm install`.\n\n```javascript\n  loadNpmTasks: [\"npm_task_to_load\"]\n```\n\n### Adding Custom tasks\n\nLineman will automatically require all files in the `tasks` directory and load them into Grunt. If you have custom tasks, you\ncan leave them there and add them to the build as above.\n\n### Using Sass\n\nLineman supports [Sass](http://sass-lang.com/) via [grunt-contrib-sass](https://github.com/gruntjs/grunt-contrib-sass). Because the `sass` task requires Ruby & the \"sass\" gem to be installed in order to function, it is disabled by default.\n\nFirst, to enable sass, in your `config/application.js` file, specify:\n\n``` javascript\nenableSass: true\n```\n\nOnce Sass is enabled, it will look for a \"main.scss\" or \"main.sass\" file in `app/css`. Rather than concatenating all the source files you include in your project, Sass files will only be included as you `@import` them from your main file. For more information on overriding the options in grunt-contrib-sass, please check out its [README](https://github.com/gruntjs/grunt-contrib-sass).\n\n## Troubleshooting\n\n### Too Many Open Files\n\nThe `lineman run` command keeps file handles on all your projects files at once. If you're seeing a message that looks like this:\n\n    undefined: [Lundefined:Cundefined] EMFILE, too many open files\n\nOr this\n\n    Error: watch Unknown system errno 23\n\nThen it probably means your project has gotten big enough to either run into the user limit on open file descriptors or (in the case of the latter), the hard limit on your operating system's file table .\n\nTo resolve this issue, we recommend first increasing the user limit on open files with the `ulimit` command. You might do this at the beginning of any terminal session or in your `~/.profile` dotfile.\n\n    ulimit -n 2048\n\n# Deployment\n\n## Static assets\n\nThe great thing about a tool whose focus is narrowly on HTML, CSS, and JavaScript is that's *all you have to worry about* when it comes time to deploy. When you're ready to deploy, just run:\n\n```\n$ lineman build\n```\n\nAnd this will place a version of your app with minified assets that's ready to be deployed wherever you like. Maybe you'll plan on integrating it with your server-side's existing deployment, or maybe you'll host the files on a static file server.\n\n## Heroku\n\nDeploying your app to [heroku](http://heroku.com) couldn't be easier. Once you have the [heroku toolbelt](https://toolbelt.heroku.com) installed, simply run this from your project:\n\n```\nheroku create --stack cedar --buildpack http://github.com/testdouble/heroku-buildpack-lineman.git\n```\n\nNow, whenever you `git push heroku`, our [custom buildpack](http://github.com/testdouble/heroku-buildpack-lineman) will build your project with lineman and then start serving your minified site assets with apache!\n\nWhat's really neat about this workflow is that while heroku takes care of building the assets for you (meaning you don't have to worry about checking in or transferring any generated assets), at runtime node is nowhere to be found! Your site is just static assets running on apache.\n\n# About\n\n## the name\n\nLineman got its name from finding that the word \"grunt\" was first used to describe unskilled railroad workers. Grunts that made the cut were promoted to linemen.\n\n## the motivation\n\nMost fat-client web applications are still written as second-class denizens within server-side project directories. This has inhibited the formation of a coherent community of people who write applications HTML, CSS, and JavaScript, because the server-side technology is dominant. Front-end work on a Rails project differs greatly from front-end work on a Java project, even though they're building the same thing!\n\nAll we wanted was a cozy & productive application development tool that didn't saddle our client-side code with a particular server-side technology. Intentionally dividing backend and front-end projects applies a healthy pressure to decouple the two.\n\nIt doesn't hurt that with Lineman, we're able to bootstrap new client-side apps faster than we ever have before.\n\n## the terms\n\nLineman was created by [test double](http://testdouble.com), a software studio in Columbus, Ohio. It's distributed under the [MIT license](http://mit-license.org).\n\n# Running Lineman's Tests\n\nIf you're interested in contributing to Lineman, it's probably worth knowing how to run Lineman's tests. It's a little tricky, because we're using Ruby & RSpec to integration-test a node project.\n\nOnce you've cloned lineman, here's all you need to install lineman's dependencies and the run its tests.\n\n``` bash\n$ npm install\n$ cd test\n$ bundle install\n$ bundle exec rspec\n```\n\n\n",
  "readmeFilename": "README.md",
  "_id": "lineman@0.8.2",
  "_from": "lineman@0.8.2"
}
